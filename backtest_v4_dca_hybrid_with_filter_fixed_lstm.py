# -*- coding: utf-8 -*-
"""
================================================================================
V4 DCA + AI Hybrid ÊúâÊøæÁ∂≤ Fixed LSTM ÂõûÊ∏¨
(With Filter + Fixed LSTM Backtest)
================================================================================
ÁµêÂêà DCA Hybrid Á≠ñÁï•ËàáÂõ∫ÂÆö LSTM Ê®°ÂûãÂäüËÉΩ„ÄÇ
‰ΩøÁî®Âõ∫ÂÆöÁöÑ LSTM Ê®°ÂûãÔºàÂæåÁ∂¥ _fixedÔºâÔºåÁ¢∫‰øùÊØèÊ¨°ÂõûÊ∏¨ÁµêÊûúÂÆåÂÖ®‰∏ÄËá¥„ÄÇ

**ÊøæÁ∂≤ (Filter)**: AI Ë≤∑ÂÖ•ÂøÖÈ†àÂêåÊôÇÊªøË∂≥:
1. Signal_Buy_Filter = True (Donchian Á™ÅÁ†¥Ë®äËôü)
2. AI Ê®°ÂûãÂà§Êñ∑ BUY

**Fixed LSTM ÁâπÈªû**:
- È¶ñÊ¨°Âü∑Ë°åÊôÇË®ìÁ∑¥ LSTM ‰∏¶ÂÑ≤Â≠òÁÇ∫ _fixed ÁâàÊú¨
- ÂæåÁ∫åÂü∑Ë°åÊúÉËá™ÂãïÂÅµÊ∏¨‰∏¶‰ΩøÁî®ÁèæÊúâÁöÑ _fixed Ê®°Âûã
- ‰øùË≠âÊØèÊ¨°ÂõûÊ∏¨‰ΩøÁî®Áõ∏ÂêåÁöÑ LSTMÔºåÁµêÊûúÂÆåÂÖ®‰∏ÄËá¥

LSTM Ë®ìÁ∑¥Ë®≠ÂÆöÔºö
- T+1:  ÈÅéÂéª 2000 Â§©
- T+5:  ÈÅéÂéª 2200 Â§©
- T+20: ÈÅéÂéª 2400 Â§©
- split_ratio: 0.99 (ÂÖ®ÈáèË®ìÁ∑¥)

‰ΩúËÄÖÔºöPhil Liang (Generated by Claude)
Êó•ÊúüÔºö2025-12-15
================================================================================
"""

import os
import sys
import pickle
import argparse
import subprocess
import glob
from datetime import datetime, timedelta

# Windows UTF-8 Ë®≠ÂÆö
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from stable_baselines3 import PPO

# ‰∏≠ÊñáÂ≠óÂûãË®≠ÂÆö
plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

# =============================================================================
# Ë®≠ÂÆö
# =============================================================================
PROJECT_PATH = os.path.dirname(os.path.abspath(__file__))
V4_MODELS_PATH = os.path.join(PROJECT_PATH, 'models_hybrid_v4')
RESULTS_PATH = os.path.join(PROJECT_PATH, 'results_backtest_v4_dca_hybrid_with_filter_fixed_lstm')
CACHE_DIR = os.path.join(PROJECT_PATH, 'data', 'processed')

# Fixed LSTM ÂæåÁ∂¥
FIXED_LSTM_SUFFIX = '_fixed'

# LSTM Ë®ìÁ∑¥ËÖ≥Êú¨
SCRIPT_1D = 'twii_model_registry_multivariate.py'
SCRIPT_5D = 'twii_model_registry_5d.py'
SCRIPT_20D = 'twii_model_registry_20d.py'

# LSTM Ë®ìÁ∑¥Ë®≠ÂÆö (ÂèÉËÄÉ daily_ops_v4.py)
TRAIN_DAYS_1D = 2000   # T+1 Ê®°ÂûãË®ìÁ∑¥Â§©Êï∏
TRAIN_DAYS_5D = 2200   # T+5 Ê®°ÂûãË®ìÁ∑¥Â§©Êï∏
TRAIN_DAYS_20D = 2400  # T+20 Ê®°ÂûãË®ìÁ∑¥Â§©Êï∏
TRAIN_SPLIT_RATIO = "0.99"  # ÂÖ®ÈáèË®ìÁ∑¥

DEFAULT_START_DATE = '2023-01-01'  
DEFAULT_END_DATE = None
YEARLY_CAPITAL = 600_000  
MONTHLY_DCA_BENCHMARK = 50_000  


def parse_args():
    parser = argparse.ArgumentParser(
        description='V4 DCA + AI Hybrid Fixed LSTM Backtest',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('--start', type=str, default=DEFAULT_START_DATE)
    parser.add_argument('--end', type=str, default=DEFAULT_END_DATE)
    return parser.parse_args()


def get_fixed_lstm_paths(train_end_date: str) -> dict:
    """
    ÂèñÂæó Fixed LSTM Ê®°ÂûãÁöÑÈ†êÊúüË∑ØÂæë
    
    Args:
        train_end_date: Ë®ìÁ∑¥Êà™Ê≠¢Êó•Êúü
    
    Returns:
        ÂåÖÂê´ÂêÑÊ®°ÂûãÈ†êÊúüË∑ØÂæëÁöÑÂ≠óÂÖ∏
    """
    end_dt = datetime.strptime(train_end_date, '%Y-%m-%d')
    start_1d = (end_dt - timedelta(days=TRAIN_DAYS_1D)).strftime('%Y-%m-%d')
    start_5d = (end_dt - timedelta(days=TRAIN_DAYS_5D)).strftime('%Y-%m-%d')
    start_20d = (end_dt - timedelta(days=TRAIN_DAYS_20D)).strftime('%Y-%m-%d')
    
    return {
        'model_1d': {
            'dir': os.path.join(PROJECT_PATH, 'saved_models_multivariate'),
            'pattern': f'model_{start_1d}_{train_end_date}{FIXED_LSTM_SUFFIX}.keras',
            'start': start_1d,
            'end': train_end_date
        },
        'model_5d': {
            'dir': os.path.join(PROJECT_PATH, 'saved_models_5d'),
            'pattern': f'model_{start_5d}_{train_end_date}{FIXED_LSTM_SUFFIX}.keras',
            'start': start_5d,
            'end': train_end_date
        },
        'model_20d': {
            'dir': os.path.join(PROJECT_PATH, 'saved_models_20d'),
            'pattern': f'model_{start_20d}_{train_end_date}{FIXED_LSTM_SUFFIX}.keras',
            'start': start_20d,
            'end': train_end_date
        }
    }


def check_fixed_lstm_exists(train_end_date: str) -> dict:
    """
    Ê™¢Êü•ÊòØÂê¶Â≠òÂú®Á¨¶ÂêàÊ¢ù‰ª∂ÁöÑ Fixed LSTM Ê®°Âûã
    
    Returns:
        dict: {'all_exist': bool, 'paths': {Ê®°ÂûãË∑ØÂæë}, 'missing': [Áº∫Â∞ëÁöÑÊ®°Âûã]}
    """
    paths = get_fixed_lstm_paths(train_end_date)
    result = {'all_exist': True, 'paths': {}, 'missing': []}
    
    for model_name, info in paths.items():
        model_path = os.path.join(info['dir'], info['pattern'])
        if os.path.exists(model_path):
            result['paths'][model_name] = model_path
        else:
            result['all_exist'] = False
            result['missing'].append(model_name)
    
    return result


def train_and_save_fixed_lstm(train_end_date: str) -> bool:
    """
    Ë®ìÁ∑¥ LSTM Ê®°Âûã‰∏¶ÂÑ≤Â≠òÁÇ∫ _fixed ÁâàÊú¨
    """
    print("\n" + "=" * 60)
    print("üìö Step 0: Ë®ìÁ∑¥‰∏¶ÂÑ≤Â≠ò Fixed LSTM Ê®°Âûã")
    print("=" * 60)
    
    end_dt = datetime.strptime(train_end_date, '%Y-%m-%d')
    start_1d = (end_dt - timedelta(days=TRAIN_DAYS_1D)).strftime('%Y-%m-%d')
    start_5d = (end_dt - timedelta(days=TRAIN_DAYS_5D)).strftime('%Y-%m-%d')
    start_20d = (end_dt - timedelta(days=TRAIN_DAYS_20D)).strftime('%Y-%m-%d')
    
    print(f"  Ë®ìÁ∑¥Êà™Ê≠¢Êó•: {train_end_date}")
    print(f"  T+1 Ë®ìÁ∑¥ÊúüÈñì:  {start_1d} ~ {train_end_date} ({TRAIN_DAYS_1D} Â§©)")
    print(f"  T+5 Ë®ìÁ∑¥ÊúüÈñì:  {start_5d} ~ {train_end_date} ({TRAIN_DAYS_5D} Â§©)")
    print(f"  T+20 Ë®ìÁ∑¥ÊúüÈñì: {start_20d} ~ {train_end_date} ({TRAIN_DAYS_20D} Â§©)")
    print(f"  Split Ratio: {TRAIN_SPLIT_RATIO}")
    
    paths = get_fixed_lstm_paths(train_end_date)
    
    # Ë®ìÁ∑¥ÂêÑÊ®°Âûã
    training_configs = [
        ('T+1', SCRIPT_1D, start_1d, 'saved_models_multivariate'),
        ('T+5', SCRIPT_5D, start_5d, 'saved_models_5d'),
        ('T+20', SCRIPT_20D, start_20d, 'saved_models_20d'),
    ]
    
    for model_name, script, start_date, save_dir in training_configs:
        print(f"\n[Training] {model_name} Model...")
        script_path = os.path.join(PROJECT_PATH, script)
        cmd = [
            sys.executable, script_path, "train",
            "--start", start_date, "--end", train_end_date,
            "--split_ratio", TRAIN_SPLIT_RATIO
        ]
        try:
            subprocess.run(cmd, check=True, timeout=600, cwd=PROJECT_PATH)
            print(f"[Training] ‚úÖ {model_name} Ë®ìÁ∑¥ÂÆåÊàê")
            
            # ÈáçÂëΩÂêçÁÇ∫ _fixed ÁâàÊú¨
            src_pattern = os.path.join(PROJECT_PATH, save_dir, f'model_{start_date}_{train_end_date}.keras')
            if os.path.exists(src_pattern):
                dst_path = src_pattern.replace('.keras', f'{FIXED_LSTM_SUFFIX}.keras')
                import shutil
                shutil.copy2(src_pattern, dst_path)
                print(f"[Fixed] Â∑≤ÂÑ≤Â≠òÁÇ∫: {os.path.basename(dst_path)}")
                
                # Ë§áË£ΩÁõ∏ÈóúÁöÑ scaler Âíå meta Ê™îÊ°à
                for suffix in ['feature_scaler', 'target_scaler', 'meta']:
                    src_file = src_pattern.replace('model_', f'{suffix}_').replace('.keras', '.pkl' if 'scaler' in suffix else '.json')
                    if os.path.exists(src_file):
                        dst_file = src_file.replace('.pkl', f'{FIXED_LSTM_SUFFIX}.pkl').replace('.json', f'{FIXED_LSTM_SUFFIX}.json')
                        shutil.copy2(src_file, dst_file)
                        
        except Exception as e:
            print(f"[Error] {model_name} Ë®ìÁ∑¥Â§±Êïó: {e}")
            return False
    
    # Ê∏ÖÈô§ÁâπÂæµÂø´Âèñ
    print("\n[Cache] Ê∏ÖÈô§ÁâπÂæµÂø´Âèñ...")
    cache_files = glob.glob(os.path.join(CACHE_DIR, "*.pkl"))
    for f in cache_files:
        try:
            os.remove(f)
            print(f"  Âà™Èô§: {os.path.basename(f)}")
        except:
            pass
    
    print("\n[Done] Fixed LSTM Ë®ìÁ∑¥ËàáÂÑ≤Â≠òÂÆåÊàêÔºÅ")
    return True


def find_or_train_fixed_lstm(train_end_date: str) -> dict:
    """
    Â∞ãÊâæÊàñË®ìÁ∑¥ Fixed LSTM Ê®°Âûã
    
    Returns:
        dict: ÂåÖÂê´Ê®°ÂûãË∑ØÂæëÁöÑË≥áË®äÔºåÁî®ÊñºÂæåÁ∫åËºâÂÖ•
    """
    print("\n" + "=" * 60)
    print("üîç Step 0: Â∞ãÊâæÊàñË®ìÁ∑¥ Fixed LSTM Ê®°Âûã")
    print("=" * 60)
    
    # Ê™¢Êü•ÊòØÂê¶Â≠òÂú®
    check_result = check_fixed_lstm_exists(train_end_date)
    
    if check_result['all_exist']:
        print("[Fixed LSTM] ‚úÖ ÊâæÂà∞ÁèæÊúâÁöÑ Fixed LSTM Ê®°Âûã:")
        for model_name, path in check_result['paths'].items():
            print(f"  {model_name}: {os.path.basename(path)}")
        return check_result
    else:
        print("[Fixed LSTM] ‚ö†Ô∏è Áº∫Â∞ë‰ª•‰∏ã Fixed LSTM Ê®°Âûã:")
        for missing in check_result['missing']:
            print(f"  - {missing}")
        print("\n[Fixed LSTM] ÈñãÂßãË®ìÁ∑¥...")
        
        if train_and_save_fixed_lstm(train_end_date):
            # ÈáçÊñ∞Ê™¢Êü•
            return check_fixed_lstm_exists(train_end_date)
        else:
            return {'all_exist': False, 'paths': {}, 'missing': ['ÂÖ®ÈÉ®']}


def load_fixed_lstm_models(train_end_date: str, lstm_info: dict) -> bool:
    """ËºâÂÖ• Fixed LSTM Ê®°Âûã"""
    import ptrl_hybrid_system as hybrid
    from tensorflow import keras
    
    try:
        from twii_model_registry_5d import SelfAttention
    except ImportError:
        print("[Error] ÁÑ°Ê≥ïËºâÂÖ• SelfAttention È°ûÂà•")
        return False
    
    paths = get_fixed_lstm_paths(train_end_date)
    
    print(f"\n[LSTM] ËºâÂÖ• Fixed LSTM Ê®°Âûã (train_end: {train_end_date})")
    
    models = {}
    for model_key, info in paths.items():
        model_path = os.path.join(info['dir'], info['pattern'])
        
        if not os.path.exists(model_path):
            print(f"[Error] Êâæ‰∏çÂà∞ {model_key}: {model_path}")
            return False
        
        # ËºâÂÖ•Ê®°Âûã
        model = keras.models.load_model(model_path, custom_objects={'SelfAttention': SelfAttention})
        
        # ËºâÂÖ• scalers
        scaler_feat_path = model_path.replace('model_', 'feature_scaler_').replace('.keras', '.pkl')
        scaler_tgt_path = model_path.replace('model_', 'target_scaler_').replace('.keras', '.pkl')
        meta_path = model_path.replace('model_', 'meta_').replace('.keras', '.json')
        
        scaler_feat = None
        scaler_tgt = None
        meta = {}
        
        if os.path.exists(scaler_feat_path):
            with open(scaler_feat_path, 'rb') as f:
                scaler_feat = pickle.load(f)
        if os.path.exists(scaler_tgt_path):
            with open(scaler_tgt_path, 'rb') as f:
                scaler_tgt = pickle.load(f)
        if os.path.exists(meta_path):
            import json
            with open(meta_path, 'r', encoding='utf-8') as f:
                meta = json.load(f)
        
        suffix = model_key.split('_')[1]  # 1d, 5d, 20d
        models[f'model_{suffix}'] = model
        models[f'scaler_feat_{suffix}'] = scaler_feat
        models[f'scaler_tgt_{suffix}'] = scaler_tgt if scaler_tgt else scaler_feat
        models[f'meta_{suffix}'] = meta
        
        print(f"  ‚úÖ {model_key}: {os.path.basename(model_path)}")
    
    models['loaded'] = True
    hybrid._LSTM_MODELS.update(models)
    return True


def save_lstm_info(train_end_date: str, results_path: str) -> str:
    """ÂÑ≤Â≠ò LSTM Ê®°ÂûãË≥áË®äÂà∞ JSON Ê™îÊ°à"""
    import json
    
    paths = get_fixed_lstm_paths(train_end_date)
    
    lstm_info = {
        'train_end_date': train_end_date,
        'created_at': datetime.now().isoformat(),
        'models': {}
    }
    
    for model_key, info in paths.items():
        model_path = os.path.join(info['dir'], info['pattern'])
        lstm_info['models'][model_key] = {
            'path': model_path,
            'basename': os.path.basename(model_path),
            'start_date': info['start'],
            'end_date': info['end']
        }
    
    # ÂÑ≤Â≠òÂà∞ÁµêÊûúÁõÆÈåÑ
    os.makedirs(results_path, exist_ok=True)
    info_path = os.path.join(results_path, f'lstm_info_{train_end_date.replace("-", "")}.json')
    
    with open(info_path, 'w', encoding='utf-8') as f:
        json.dump(lstm_info, f, indent=2, ensure_ascii=False)
    
    print(f"[Output] LSTM Info: {info_path}")
    return info_path



# =============================================================================
# Strategy 1: Split 50/50 (Injection Mode)
# =============================================================================
class DCAHybridBacktester:
    def __init__(self, buy_model, sell_model, yearly_capital=600_000):
        self.buy_model = buy_model
        self.sell_model = sell_model
        self.yearly_capital = yearly_capital
        
        self.trades = []
        self.equity_curve = []
        self.dca_buy_signals = []      
        self.ai_buy_signals = []       
        self.ai_sell_signals = []      
        self.daily_confidence = []     
        self.total_invested = 0
    
    def run(self, df: pd.DataFrame, feature_cols: list) -> dict:
        features = df[feature_cols].values.astype(np.float32)
        close_prices = df['Close'].values
        dates = df.index
        
        # ËÆÄÂèñÊøæÁ∂≤Ë®äËôü
        if 'Signal_Buy_Filter' in df.columns:
            filter_signals = df['Signal_Buy_Filter'].values
        else:
            print("[Warning] Êâæ‰∏çÂà∞ Signal_Buy_Filter Ê¨Ñ‰ΩçÔºåÊøæÁ∂≤Â∞áÂ§±Êïà (ÂÖ®ÈÄöÈÅé)")
            filter_signals = np.ones(len(df))
        
        dca_limit = 0       
        ai_limit = 0        
        dca_shares = 0      
        dca_internal_cash = 0  
        ai_internal_cash = 0   
        ai_position = None     
        
        current_year = None
        last_dca_month = None
        
        print(f"[Strategy 1] Period: {dates[0].strftime('%Y-%m-%d')} ~ {dates[-1].strftime('%Y-%m-%d')}")
        print(f"[Strategy 1] Yearly Limit: ${self.yearly_capital:,.0f} (Split 50/50)")
        print(f"[Strategy 1] MODE: WITH FILTER (Signal_Buy_Filter)")
        
        for i in range(len(df)):
            date = dates[i]
            price = close_prices[i]
            year = date.year
            month = date.month
            
            if current_year != year:
                current_year = year
                last_dca_month = None
                dca_limit += self.yearly_capital / 2
                ai_limit += self.yearly_capital / 2
                print(f"  [{year}] New Year +${self.yearly_capital:,.0f}. DCA Lim: {dca_limit:,.0f}, AI Lim: {ai_limit:,.0f}")

            # DCA (Monthly)
            if last_dca_month != month:
                last_dca_month = month
                target_amt = 25_000 # Fixed 300k / 12
                needed = target_amt - dca_internal_cash
                
                if needed > 0:
                    inj_amount = min(needed, dca_limit)
                    dca_limit -= inj_amount
                    dca_internal_cash += inj_amount
                    self.total_invested += inj_amount
                
                if dca_internal_cash >= price:
                    shares = int(dca_internal_cash / price)
                    cost = shares * price
                    dca_internal_cash -= cost
                    dca_shares += shares
                    self.dca_buy_signals.append((date, price, shares))
            
            # AI
            obs = np.nan_to_num(features[i], nan=0.0, posinf=1.0, neginf=-1.0)
            
            if ai_position is not None:
                current_return = price / ai_position['buy_price']
                hold_days = i - ai_position['buy_idx']
                sell_obs = np.concatenate([obs, [current_return]]).astype(np.float32).reshape(1, -1)
                action, _ = self.sell_model.predict(sell_obs, deterministic=True)
                sell_probs = self.sell_model.policy.get_distribution(self.sell_model.policy.obs_to_tensor(sell_obs)[0]).distribution.probs.detach().cpu().numpy()[0]
                sell_conf = float(sell_probs[1]) if action[0] == 1 else float(sell_probs[0])
                
                log_entry = {'date': date, 'status': 'holding', 'price': price, 'sell_conf': sell_conf, 'buy_conf': 0, 'action': 'hold'}
                self.daily_confidence.append(log_entry)
                
                if action[0] == 1 or current_return < 0.92 or hold_days >= 120:
                    log_entry['action'] = 'SELL'
                    proceeds = ai_position['shares'] * price
                    profit = proceeds - ai_position['cost']
                    ai_internal_cash += proceeds
                    self.trades.append({'type': 'AI', 'return': current_return - 1, 'profit': profit, 'hold_days': hold_days})
                    self.ai_sell_signals.append({'date': date, 'price': price, 'confidence': sell_conf})
                    ai_position = None
            
            elif ai_position is None:
                available_fund = ai_internal_cash + ai_limit
                buy_conf = 0
                filter_pass = bool(filter_signals[i])
                
                if available_fund >= price:
                    buy_obs = obs.reshape(1, -1)
                    action, _ = self.buy_model.predict(buy_obs, deterministic=True)
                    buy_probs = self.buy_model.policy.get_distribution(self.buy_model.policy.obs_to_tensor(buy_obs)[0]).distribution.probs.detach().cpu().numpy()[0]
                    buy_conf = float(buy_probs[1]) if action[0] == 1 else float(buy_probs[0])
                    
                    log_entry = {'date': date, 'status': 'idle_check_buy', 'price': price, 'buy_conf': buy_conf, 'filter_pass': filter_pass, 'sell_conf': 0, 'action': 'wait'}
                    self.daily_confidence.append(log_entry)

                    if action[0] == 1:
                        # AI ÊÉ≥Ë≤∑ - Ê™¢Êü•ÊøæÁ∂≤
                        if filter_pass:
                            # 100% Invest
                            invest_amt = available_fund
                            used_internal = min(ai_internal_cash, invest_amt)
                            needed_external = invest_amt - used_internal
                            
                            if ai_limit >= needed_external:
                                log_entry['action'] = 'BUY'
                                ai_limit -= needed_external
                                ai_internal_cash += needed_external
                                self.total_invested += needed_external
                                
                                shares = int(invest_amt / price)
                                cost = shares * price
                                ai_internal_cash -= cost
                                ai_position = {'shares': shares, 'buy_price': price, 'buy_idx': i, 'cost': cost}
                                self.ai_buy_signals.append({'date': date, 'price': price, 'confidence': buy_conf})
                        else:
                            # AI ÊÉ≥Ë≤∑‰ΩÜË¢´ÊøæÁ∂≤ÊîîÊà™
                            log_entry['action'] = 'FILTERED'


            # Value = Assets + Internal Cash
            total_val = (dca_shares * price + dca_internal_cash) + \
                        ((ai_position['shares'] * price if ai_position else 0) + ai_internal_cash)
            
            self.equity_curve.append({'date': date, 'value': total_val})
            
        return self._calculate_metrics()

    def _calculate_metrics(self) -> dict:
        if not self.equity_curve: return {}
        equity_df = pd.DataFrame(self.equity_curve).set_index('date')
        final = equity_df['value'].iloc[-1]
        total_return = (final - self.total_invested) / self.total_invested if self.total_invested > 0 else 0
        days = (equity_df.index[-1] - equity_df.index[0]).days
        annualized = (1 + total_return) ** (365/days) - 1 if days > 0 else 0
        
        daily_ret = equity_df['value'].pct_change().fillna(0)
        sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
        
        roll_max = equity_df['value'].cummax()
        max_dd = ((equity_df['value'] - roll_max) / roll_max).min()
        
        wins = sum(1 for t in self.trades if t['return'] > 0)
        win_rate = wins / len(self.trades) if self.trades else 0
        
        return {
            'total_invested': self.total_invested,
            'final_value': final,
            'total_return': total_return,
            'annualized_return': annualized,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_dd,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'equity_df': equity_df,
            'dca_buys': len(self.dca_buy_signals),
            'ai_buys': len(self.ai_buy_signals)
        }


# =============================================================================
# Strategy 2: Shared Pool (Injection Mode) - WITH FILTER
# =============================================================================
class SharedPoolBacktester:
    def __init__(self, buy_model, sell_model, yearly_capital=600_000, 
                 dca_amount=50_000, ai_chunk_amount=50_000):
        self.buy_model = buy_model
        self.sell_model = sell_model
        self.yearly_capital = yearly_capital
        self.dca_amount = dca_amount
        self.ai_chunk_amount = ai_chunk_amount
        
        self.trades = []
        self.equity_curve = []
        self.dca_buy_signals = []      
        self.ai_buy_signals = []       
        self.ai_sell_signals = []
        self.filtered_signals = []     # AIÊÉ≥Ë≤∑‰ΩÜË¢´ÊøæÁ∂≤Êìã‰∏ãÁöÑË®äËôü
        self.daily_confidence = []
        self.daily_action_summary = []  # ÊØèÊó•Êìç‰ΩúÊëòË¶Å (‰∏ÄÂ§©‰∏ÄÁ≠Ü)
        self.open_positions = []       # ÂõûÊ∏¨ÁµêÊùüÊôÇÁöÑÊú™Âπ≥ÂÄâ AI ÊåÅÂÄâ
        self.total_invested = 0

    def run(self, df: pd.DataFrame, feature_cols: list) -> dict:
        features = df[feature_cols].values.astype(np.float32)
        close_prices = df['Close'].values
        dates = df.index
        
        # ËÆÄÂèñÊøæÁ∂≤Ë®äËôü
        if 'Signal_Buy_Filter' in df.columns:
            filter_signals = df['Signal_Buy_Filter'].values
        else:
            print("[Warning] Êâæ‰∏çÂà∞ Signal_Buy_Filter Ê¨Ñ‰ΩçÔºåÊøæÁ∂≤Â∞áÂ§±Êïà (ÂÖ®ÈÄöÈÅé)")
            filter_signals = np.ones(len(df))
        
        external_limit = 0     
        internal_cash = 0      
        dca_shares = 0
        ai_positions = []      
        
        current_year = None
        last_dca_month = None
        
        print(f"[Strategy 2] Period: {dates[0].strftime('%Y-%m-%d')} ~ {dates[-1].strftime('%Y-%m-%d')}")
        print(f"[Strategy 2] Shared Limit: Yearly +${self.yearly_capital:,.0f}")
        print(f"[Strategy 2] MODE: WITH FILTER (Signal_Buy_Filter)")
        
        for i in range(len(df)):
            date = dates[i]
            price = close_prices[i]
            year = date.year
            month = date.month
            
            if current_year != year:
                current_year = year
                last_dca_month = None
                external_limit += self.yearly_capital
                print(f"  [{year}] +${self.yearly_capital:,.0f} Lim. Avail Ext: {external_limit:,.0f}, Int Cash: {internal_cash:,.0f}")

            def try_allocate_funds(amount):
                nonlocal internal_cash, external_limit
                allocated = 0
                if internal_cash >= amount:
                    internal_cash -= amount
                    allocated = amount
                else:
                    use_int = internal_cash
                    needed = amount - use_int
                    if external_limit >= needed:
                        internal_cash = 0
                        external_limit -= needed
                        self.total_invested += needed 
                        allocated = amount
                return allocated

            # DCA (Monthly)
            day_dca_shares = 0  # Áï∂Êó• DCA Ë≤∑ÂÖ•ËÇ°Êï∏
            if last_dca_month != month:
                last_dca_month = month
                fund = try_allocate_funds(self.dca_amount)
                if fund > 0:
                    shares = int(fund / price)
                    cost = shares * price
                    internal_cash += (fund - cost)
                    dca_shares += shares
                    day_dca_shares = shares
                    self.dca_buy_signals.append((date, price, shares))
            
            # AI
            obs = np.nan_to_num(features[i], nan=0.0, posinf=1.0, neginf=-1.0)
            
            # Áï∂Êó•ËøΩËπ§ËÆäÊï∏
            day_action = 'HOLD'
            day_buy_conf = None
            day_sell_conf = None
            day_note = ''
            day_sold_count = 0
            day_bought_shares = 0
            
            # Ê™¢Êü•ÊåÅÂÄâË≥£Âá∫
            max_sell_conf_today = 0
            for idx in range(len(ai_positions) - 1, -1, -1):
                pos = ai_positions[idx]
                hold_days = i - pos['buy_idx']
                current_return = price / pos['buy_price']
                sell_obs = np.concatenate([obs, [current_return]]).astype(np.float32).reshape(1, -1)
                action, _ = self.sell_model.predict(sell_obs, deterministic=True)
                
                sell_probs = self.sell_model.policy.get_distribution(self.sell_model.policy.obs_to_tensor(sell_obs)[0]).distribution.probs.detach().cpu().numpy()[0]
                sell_conf = float(sell_probs[1]) if action[0] == 1 else float(sell_probs[0])
                max_sell_conf_today = max(max_sell_conf_today, sell_conf)
                
                log_entry = {'date': date, 'status': 'holding', 'price': price, 'sell_conf': sell_conf, 'buy_conf': 0, 'action': 'hold'}
                self.daily_confidence.append(log_entry)
                
                if action[0] == 1 or current_return < 0.92 or hold_days >= 120:
                    log_entry['action'] = 'SELL'
                    proceeds = pos['shares'] * price
                    profit = proceeds - pos['cost']
                    internal_cash += proceeds 
                    self.trades.append({'type': 'AI_S2', 'return': current_return - 1, 'profit': profit, 'hold_days': hold_days})
                    self.ai_sell_signals.append({'date': date, 'price': price, 'confidence': sell_conf})
                    ai_positions.pop(idx)
                    day_action = 'SELL'
                    day_sell_conf = sell_conf
                    day_sold_count += 1

            # Ê™¢Êü•Ë≤∑ÂÖ• (ÊúâÊøæÁ∂≤)
            filter_pass = bool(filter_signals[i])
            day_filtered = False
            
            if (internal_cash + external_limit) >= self.ai_chunk_amount:
                buy_obs = obs.reshape(1, -1)
                action, _ = self.buy_model.predict(buy_obs, deterministic=True)
                buy_probs = self.buy_model.policy.get_distribution(self.buy_model.policy.obs_to_tensor(buy_obs)[0]).distribution.probs.detach().cpu().numpy()[0]
                buy_conf = float(buy_probs[1]) if action[0] == 1 else float(buy_probs[0])
                day_buy_conf = buy_conf
                
                log_entry = {'date': date, 'status': 'check_buy', 'price': price, 'buy_conf': buy_conf, 'filter_pass': filter_pass, 'action': 'wait'}
                self.daily_confidence.append(log_entry)

                if action[0] == 1:
                    # AI ÊÉ≥Ë≤∑ - Ê™¢Êü•ÊøæÁ∂≤
                    if filter_pass:
                        fund = try_allocate_funds(self.ai_chunk_amount)
                        if fund > 0:
                            log_entry['action'] = 'BUY'
                            shares = int(fund / price)
                            cost = shares * price
                            internal_cash += (fund - cost)
                            ai_positions.append({'shares': shares, 'buy_price': price, 'buy_idx': i, 'cost': cost})
                            self.ai_buy_signals.append({'date': date, 'price': price, 'confidence': buy_conf})
                            day_action = 'BUY'
                            day_bought_shares = shares
                    else:
                        # AI ÊÉ≥Ë≤∑‰ΩÜË¢´ÊøæÁ∂≤ÊîîÊà™
                        log_entry['action'] = 'FILTERED'
                        self.filtered_signals.append({'date': date, 'price': price, 'confidence': buy_conf})
                        day_filtered = True
            
            # Áî¢ÁîüÁï∂Êó•ÊëòË¶Å - Ê†ºÂºè: DCAË≤∑Ë≥£, AIË≤∑Ë≥£, Á∏ΩÂÄâÊï∏
            # DCA Ë¶ñÁÇ∫ÊØèÊúàË≤∑1ÂÄâ (50k), AI ÊØèÁ≠ÜË≤∑1ÂÄâ (50k)
            dca_position_count = len(self.dca_buy_signals)  # DCAË≤∑ÂÖ•Ê¨°Êï∏=DCAÂÄâÊï∏
            notes = []
            
            # ÂàÜÂà•ËøΩËπ§ DCA„ÄÅAIË≥£Âá∫„ÄÅAIË≤∑ÂÖ• (‰∏çÁî® day_actionÔºåÈÅøÂÖçË¢´Ë¶ÜËìã)
            if day_dca_shares > 0:
                notes.append('DCA+1ÂÄâ')
            if day_sold_count > 0:
                notes.append(f'AI-{day_sold_count}ÂÄâ')
            if day_bought_shares > 0:
                notes.append('AI+1ÂÄâ')
            
            # Á∏ΩÂÄâÊï∏ = DCAÂÄâ + AIÂÄâ
            total_positions = dca_position_count + len(ai_positions)
            notes.append(f'Áèæ{total_positions}ÂÄâ(DCA{dca_position_count}+AI{len(ai_positions)})')
            
            day_note = ', '.join(notes)
            
            # Â¶ÇÊûúÊ≤íÊúâË≤∑ÈÄ≤‰ΩÜÊúâÊ™¢Êü•Ë≤∑ÂÖ•ÔºåË®òÈåÑË≤∑ÂÖ•‰ø°ÂøÉ
            if day_sell_conf is None and len(ai_positions) > 0:
                day_sell_conf = max_sell_conf_today if max_sell_conf_today > 0 else None
            
            self.daily_action_summary.append({
                'date': date,
                'ai_action': day_action,
                'price': price,
                'ai_buy_conf': day_buy_conf,
                'ai_sell_conf': day_sell_conf,
                'ai_position_count': len(ai_positions),
                'dca_position_count': dca_position_count,
                'total_position_count': total_positions,
                'note': day_note
            })

            # Value = Stock + Internal Cash
            dca_val = dca_shares * price
            ai_val = sum(p['shares'] * price for p in ai_positions)
            total_val = dca_val + ai_val + internal_cash
            
            self.equity_curve.append({'date': date, 'value': total_val})
        
        # ‰øùÂ≠òÊú™Âπ≥ÂÄâÊåÅÂÄâ (Áî®Êñº intraday ËÖ≥Êú¨ËÆÄÂèñ)
        self.open_positions = []
        for pos in ai_positions:
            self.open_positions.append({
                'buy_date': dates[pos['buy_idx']].strftime('%Y-%m-%d'),
                'buy_price': pos['buy_price'],
                'shares': pos['shares'],
                'cost': pos['cost']
            })
            
        return self._calculate_metrics()

    def _calculate_metrics(self) -> dict:
        if not self.equity_curve: return {}
        equity_df = pd.DataFrame(self.equity_curve).set_index('date')
        final = equity_df['value'].iloc[-1]
        total_return = (final - self.total_invested) / self.total_invested if self.total_invested > 0 else 0
        days = (equity_df.index[-1] - equity_df.index[0]).days
        annualized = (1 + total_return) ** (365/days) - 1 if days > 0 else 0
        daily_ret = equity_df['value'].pct_change().fillna(0)
        sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
        roll_max = equity_df['value'].cummax()
        max_dd = ((equity_df['value'] - roll_max) / roll_max).min()
        
        wins = sum(1 for t in self.trades if t['return'] > 0)
        win_rate = wins / len(self.trades) if self.trades else 0
        return {
            'total_invested': self.total_invested,
            'final_value': final,
            'total_return': total_return,
            'annualized_return': annualized,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_dd,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'equity_df': equity_df,
            'dca_buys': len(self.dca_buy_signals),
            'ai_buys': len(self.ai_buy_signals)
        }


def calculate_pure_dca(df: pd.DataFrame, monthly_amount: float = 50_000):
    close_prices = df['Close'].values
    dates = df.index
    shares = 0
    total_invested = 0
    equity_curve = []
    last_month = None
    
    for i in range(len(df)):
        date = dates[i]
        price = close_prices[i]
        year = date.year
        month = date.month
        if last_month != month:
            last_month = month
            shares_to_buy = int(monthly_amount / price)
            if shares_to_buy > 0:
                shares += shares_to_buy
                total_invested += shares_to_buy * price
        equity_curve.append({'date': date, 'value': shares * price})
    
    equity_df = pd.DataFrame(equity_curve).set_index('date')
    final = equity_df['value'].iloc[-1]
    total_return = (final - total_invested) / total_invested if total_invested > 0 else 0
    
    days = (equity_df.index[-1] - equity_df.index[0]).days
    annualized = (1 + total_return) ** (365/days) - 1 if days > 0 else 0
    daily_ret = equity_df['value'].pct_change().fillna(0)
    sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
    max_dd = ((equity_df['value'] - equity_df['value'].cummax()) / equity_df['value'].cummax()).min()
    
    return {
        'total_invested': total_invested, 'final_value': final, 'total_return': total_return,
        'annualized_return': annualized, 'sharpe_ratio': sharpe, 'max_drawdown': max_dd, 'equity_df': equity_df
    }


def calculate_yearly_lumpsum(df: pd.DataFrame, yearly_amount: float = 600_000):
    close_prices = df['Close'].values
    dates = df.index
    shares = 0
    total_invested = 0
    equity_curve = []
    current_year = None
    
    for i in range(len(df)):
        date = dates[i]
        price = close_prices[i]
        year = date.year
        if current_year != year:
            current_year = year
            shares_to_buy = int(yearly_amount / price)
            if shares_to_buy > 0:
                shares += shares_to_buy
                total_invested += shares_to_buy * price
        equity_curve.append({'date': date, 'value': shares * price})
    
    equity_df = pd.DataFrame(equity_curve).set_index('date')
    final = equity_df['value'].iloc[-1]
    total_return = (final - total_invested) / total_invested if total_invested > 0 else 0
    days = (equity_df.index[-1] - equity_df.index[0]).days
    annualized = (1 + total_return) ** (365/days) - 1 if days > 0 else 0
    daily_ret = equity_df['value'].pct_change().fillna(0)
    sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
    max_dd = ((equity_df['value'] - equity_df['value'].cummax()) / equity_df['value'].cummax()).min()
    
    return {
        'total_invested': total_invested, 'final_value': final, 'total_return': total_return,
        'annualized_return': annualized, 'sharpe_ratio': sharpe, 'max_drawdown': max_dd, 'equity_df': equity_df
    }


def main():
    args = parse_args()
    start_date = pd.Timestamp(args.start)
    end_date = pd.Timestamp(args.end) if args.end else None
    
    # LSTM Ë®ìÁ∑¥Êà™Ê≠¢Êó• = ÂõûÊ∏¨ÈñãÂßãÊó• - 1 Â§©
    train_end_date = (start_date - timedelta(days=1)).strftime('%Y-%m-%d')
    
    print("=" * 70)
    print("V4 DCA + AI Hybrid ÊúâÊøæÁ∂≤ Fixed LSTM ÂõûÊ∏¨")
    print("(With Filter + Fixed LSTM Backtest)")
    print("=" * 70)
    print(f"  üìÖ ÂõûÊ∏¨ÈñãÂßãÊó•Êúü: {start_date.date()}")
    print(f"  üìÖ ÂõûÊ∏¨ÁµêÊùüÊó•Êúü: {end_date.date() if end_date else 'ÊúÄÊñ∞Ë≥áÊñô'}")
    print(f"  üìö LSTM Ë®ìÁ∑¥Êà™Ê≠¢Êó•: {train_end_date}")
    
    os.makedirs(RESULTS_PATH, exist_ok=True)
    
    # Step 0: Fixed LSTM (Â∞ãÊâæÊàñË®ìÁ∑¥)
    lstm_info = find_or_train_fixed_lstm(train_end_date)
    if not lstm_info['all_exist']:
        print("[Error] ÁÑ°Ê≥ïÂèñÂæó Fixed LSTM Ê®°Âûã")
        sys.exit(1)
    
    print("\n[Model] Loading V4 models...")
    buy_model = PPO.load(os.path.join(V4_MODELS_PATH, 'ppo_buy_twii_final.zip'))
    sell_model = PPO.load(os.path.join(V4_MODELS_PATH, 'ppo_sell_twii_final.zip'))
    
    print("\n[Data] Loading data...")
    import ptrl_hybrid_system as hybrid
    if not load_fixed_lstm_models(train_end_date, lstm_info):
        print("[Error] ÁÑ°Ê≥ïËºâÂÖ• Fixed LSTM Ê®°Âûã")
        sys.exit(1)
    
    # ÂÑ≤Â≠ò LSTM Ë≥áË®ä (‰æõ Intraday ËÖ≥Êú¨‰ΩøÁî®)
    save_lstm_info(train_end_date, RESULTS_PATH)
    
    # ‰ΩøÁî® Fixed LSTM Ë®àÁÆóÁâπÂæµ
    print("  [Compute] ‰ΩøÁî® Fixed LSTM Ë®àÁÆóÁâπÂæµ...")
    twii_raw = hybrid._load_local_twii_data(start_date="2000-01-01")
    twii_full_df = hybrid.calculate_features(twii_raw, twii_raw, ticker="^TWII", use_cache=False)
    
    twii_backtest_df = twii_full_df[twii_full_df.index >= start_date]
    if end_date: twii_backtest_df = twii_backtest_df[twii_backtest_df.index <= end_date]
    
    print("\n[Backtest] Running Strategy 1: Split 50/50...")
    bt1 = DCAHybridBacktester(buy_model, sell_model, YEARLY_CAPITAL)
    m1 = bt1.run(twii_backtest_df, hybrid.FEATURE_COLS)

    print("\n[Backtest] Running Strategy 2: Shared Pool...")
    bt2 = SharedPoolBacktester(buy_model, sell_model, YEARLY_CAPITAL)
    m2 = bt2.run(twii_backtest_df, hybrid.FEATURE_COLS)
    
    print("\n[Benchmark] Calculating benchmarks...")
    dca_bench = calculate_pure_dca(twii_backtest_df, MONTHLY_DCA_BENCHMARK)
    lump_bench = calculate_yearly_lumpsum(twii_backtest_df, YEARLY_CAPITAL)
    
    print("\n" + "=" * 110)
    print("Performance Comparison: Strat 1 (Split) vs Strat 2 (Shared) vs Benchmarks")
    print("=" * 110)
    print(f"{'Metric':<20} {'Strat 1 (Split)':>20} {'Strat 2 (Shared)':>20} {'Pure DCA (50k)':>20} {'Yearly Lump Sum':>20}")
    print("-" * 110)
    print(f"{'Total Invested':<20} ${m1['total_invested']:>18,.0f} ${m2['total_invested']:>18,.0f} ${dca_bench['total_invested']:>18,.0f} ${lump_bench['total_invested']:>18,.0f}")
    print(f"{'Final Value':<20} ${m1['final_value']:>18,.0f} ${m2['final_value']:>18,.0f} ${dca_bench['final_value']:>18,.0f} ${lump_bench['final_value']:>18,.0f}")
    print(f"{'Total Return':<20} {m1['total_return']*100:>19.2f}% {m2['total_return']*100:>19.2f}% {dca_bench['total_return']*100:>19.2f}% {lump_bench['total_return']*100:>19.2f}%")
    print(f"{'Annualized Return':<20} {m1['annualized_return']*100:>19.2f}% {m2['annualized_return']*100:>19.2f}% {dca_bench['annualized_return']*100:>19.2f}% {lump_bench['annualized_return']*100:>19.2f}%")
    print(f"{'Sharpe Ratio':<20} {m1['sharpe_ratio']:>20.2f} {m2['sharpe_ratio']:>20.2f} {dca_bench['sharpe_ratio']:>20.2f} {lump_bench['sharpe_ratio']:>20.2f}")
    print(f"{'Max Drawdown':<20} {m1['max_drawdown']*100:>19.2f}% {m2['max_drawdown']*100:>19.2f}% {dca_bench['max_drawdown']*100:>19.2f}% {lump_bench['max_drawdown']*100:>19.2f}%")
    print("-" * 110)
    print(f"{'DCA Buys':<20} {m1['dca_buys']:>20} {m2['dca_buys']:>20}")
    print(f"{'AI Trades':<20} {m1['total_trades']:>20} {m2['total_trades']:>20}")
    print(f"{'AI Win Rate':<20} {m1['win_rate']*100:>19.1f}% {m2['win_rate']*100:>19.1f}%")
    print("=" * 110)
    
    # Charts (Updated: 3 Subplots)
    fig, axes = plt.subplots(3, 1, figsize=(16, 18))
    
    # 1. Equity
    ax1 = axes[0]
    ax1.plot(m1['equity_df'].index, m1['equity_df']['value'], label='Strat 1 (Split)', color='blue', linewidth=2)
    ax1.plot(m2['equity_df'].index, m2['equity_df']['value'], label='Strat 2 (Shared)', color='purple', linewidth=2) 
    ax1.plot(dca_bench['equity_df'].index, dca_bench['equity_df']['value'], label='Pure DCA', color='orange', linewidth=1.5, linestyle='--')
    ax1.plot(lump_bench['equity_df'].index, lump_bench['equity_df']['value'], label='Yearly Lump', color='gray', linewidth=1.5, alpha=0.7)
    date_range_str = f"{twii_backtest_df.index[0].strftime('%Y-%m-%d')} ~ {twii_backtest_df.index[-1].strftime('%Y-%m-%d')}"
    ax1.set_title(f'V4 DCA+AI Hybrid Strategies Comparison ({date_range_str})', fontsize=14)
    ax1.set_ylabel('Portfolio Value ($)')
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)
    
    price_slice = twii_backtest_df['Close']
    
    # 2. Strat 1 Signals
    ax2 = axes[1]
    ax2.plot(price_slice.index, price_slice.values, label='^TWII', color='black', linewidth=1)
    if bt1.dca_buy_signals:
        dca_dates, dca_prices, _ = zip(*bt1.dca_buy_signals)
        ax2.scatter(dca_dates, dca_prices, marker='o', color='cyan', s=30, label='S1: DCA Buy', alpha=0.6)
    if bt1.ai_buy_signals:
        ai_buy_dates = [s['date'] for s in bt1.ai_buy_signals]
        ai_buy_prices = [s['price'] for s in bt1.ai_buy_signals]
        ax2.scatter(ai_buy_dates, ai_buy_prices, marker='^', color='blue', s=80, label='S1: AI Buy')
    if bt1.ai_sell_signals:
        ai_sell_dates = [s['date'] for s in bt1.ai_sell_signals]
        ai_sell_prices = [s['price'] for s in bt1.ai_sell_signals]
        ax2.scatter(ai_sell_dates, ai_sell_prices, marker='v', color='red', s=80, label='S1: AI Sell')
    ax2.set_title('Strategy 1 (Split 50/50) Trade Signals', fontsize=14)
    ax2.set_ylabel('Price')
    ax2.legend(loc='upper left')
    ax2.grid(True, alpha=0.3)
    
    # 3. Strat 2 Signals
    ax3 = axes[2]
    ax3.plot(price_slice.index, price_slice.values, label='^TWII', color='black', linewidth=1)
    if bt2.dca_buy_signals:
        dca_dates, dca_prices, _ = zip(*bt2.dca_buy_signals)
        ax3.scatter(dca_dates, dca_prices, marker='o', color='orange', s=30, label='S2: DCA Buy', alpha=0.6)
    if bt2.ai_buy_signals:
        ai_buy_dates = [s['date'] for s in bt2.ai_buy_signals]
        ai_buy_prices = [s['price'] for s in bt2.ai_buy_signals]
        ax3.scatter(ai_buy_dates, ai_buy_prices, marker='^', color='purple', s=80, label='S2: AI Buy')
    if bt2.ai_sell_signals:
        ai_sell_dates = [s['date'] for s in bt2.ai_sell_signals]
        ai_sell_prices = [s['price'] for s in bt2.ai_sell_signals]
        ax3.scatter(ai_sell_dates, ai_sell_prices, marker='v', color='green', s=80, label='S2: AI Sell')
    ax3.set_title('Strategy 2 (Shared Pool) Trade Signals', fontsize=14)
    ax3.set_ylabel('Price')
    ax3.legend(loc='upper left')
    ax3.grid(True, alpha=0.3)
    
    plt.tight_layout()
    start_str = twii_backtest_df.index[0].strftime('%Y%m%d')
    end_str = twii_backtest_df.index[-1].strftime('%Y%m%d')
    save_path = os.path.join(RESULTS_PATH, f'backtest_comparison_{start_str}_{end_str}.png')
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    print(f"\n[Output] Chart: {save_path}")
    plt.close()
    
    metrics_df = pd.DataFrame({
        'Metric': ['Total_Invested', 'Final_Value', 'Total_Return_Pct', 'Annualized_Return_Pct', 'Sharpe_Ratio', 'Max_Drawdown_Pct', 'DCA_Buys', 'AI_Trades', 'AI_Win_Rate_Pct'],
        'Strat1_Split': [m1['total_invested'], m1['final_value'], m1['total_return']*100, m1['annualized_return']*100, m1['sharpe_ratio'], m1['max_drawdown']*100, m1['dca_buys'], m1['total_trades'], m1['win_rate']*100],
        'Strat2_Shared': [m2['total_invested'], m2['final_value'], m2['total_return']*100, m2['annualized_return']*100, m2['sharpe_ratio'], m2['max_drawdown']*100, m2['dca_buys'], m2['total_trades'], m2['win_rate']*100],
        'Pure_DCA': [dca_bench['total_invested'], dca_bench['final_value'], dca_bench['total_return']*100, dca_bench['annualized_return']*100, dca_bench['sharpe_ratio'], dca_bench['max_drawdown']*100, 'N/A', 'N/A', 'N/A'],
        'Yearly_Lump': [lump_bench['total_invested'], lump_bench['final_value'], lump_bench['total_return']*100, lump_bench['annualized_return']*100, lump_bench['sharpe_ratio'], lump_bench['max_drawdown']*100, 'N/A', 'N/A', 'N/A']
    })
    metrics_path = os.path.join(RESULTS_PATH, f'metrics_comparison_{start_str}_{end_str}.csv')
    metrics_df.to_csv(metrics_path, index=False, encoding='utf-8-sig')
    print(f"[Output] Metrics: {metrics_path}")
    
    if bt2.trades:
        trades_df = pd.DataFrame(bt2.trades)
        trades_path = os.path.join(RESULTS_PATH, f'trades_strat2_{start_str}_{end_str}.csv')
        trades_df.to_csv(trades_path, index=False)
        print(f"[Output] Strat 2 Trades: {trades_path}")

    # New Exports
    if bt1.trades:
        trades1_df = pd.DataFrame(bt1.trades)
        trades1_path = os.path.join(RESULTS_PATH, f'trades_strat1_{start_str}_{end_str}.csv')
        trades1_df.to_csv(trades1_path, index=False)
        print(f"[Output] Strat 1 Trades: {trades1_path}")

    if bt1.daily_confidence:
        conf1_df = pd.DataFrame(bt1.daily_confidence)
        conf1_path = os.path.join(RESULTS_PATH, f'daily_confidence_strat1_{start_str}_{end_str}.csv')
        conf1_df.to_csv(conf1_path, index=False)
        print(f"[Output] Strat 1 Daily Confidence: {conf1_path}")

    if bt2.daily_confidence:
        conf2_df = pd.DataFrame(bt2.daily_confidence)
        conf2_path = os.path.join(RESULTS_PATH, f'daily_confidence_strat2_{start_str}_{end_str}.csv')
        conf2_df.to_csv(conf2_path, index=False)
        print(f"[Output] Strat 2 Daily Confidence: {conf2_path}")

    # =========================================================================
    # Êñ∞Â¢ûÔºöStrategy 2 ÊØèÊó•Êìç‰ΩúÂ†±Âëä (Console + CSV + PNG)
    # =========================================================================
    
    # 1. Console Ëº∏Âá∫ÊúÄËøë 30 Â§©
    print_daily_action_report(bt2.daily_action_summary, last_n_days=30)
    
    # 2. Daily Action CSV (‰∏ÄÂ§©‰∏ÄÁ≠Ü)
    if bt2.daily_action_summary:
        action_df = pd.DataFrame(bt2.daily_action_summary)
        action_path = os.path.join(RESULTS_PATH, f'daily_action_strat2_{start_str}_{end_str}.csv')
        action_df.to_csv(action_path, index=False, encoding='utf-8-sig')
        print(f"[Output] Daily Action CSV: {action_path}")
    
    # 2.5 Open Positions CSV (Êú™Âπ≥ÂÄâÊåÅÂÄâÔºå‰æõ intraday ËÖ≥Êú¨‰ΩøÁî®)
    if bt2.open_positions:
        pos_df = pd.DataFrame(bt2.open_positions)
        pos_path = os.path.join(RESULTS_PATH, f'open_positions_strat2_{start_str}_{end_str}.csv')
        pos_df.to_csv(pos_path, index=False, encoding='utf-8-sig')
        print(f"[Output] Open Positions CSV: {pos_path}")
        print(f"         Êú™Âπ≥ÂÄâ AI ÊåÅÂÄâ: {len(bt2.open_positions)} Á≠Ü")
    else:
        print(f"[Info] ÁÑ°Êú™Âπ≥ÂÄâ AI ÊåÅÂÄâ")
    
    # 3. Daily Timeline Chart
    create_daily_timeline_chart(bt2.daily_action_summary, twii_backtest_df, 
                                 os.path.join(RESULTS_PATH, f'daily_timeline_strat2_{start_str}_{end_str}.png'))


def print_daily_action_report(daily_summary: list, last_n_days: int = 30):
    """Âú®ÁµÇÁ´ØÊ©üËº∏Âá∫ÊúÄËøë N Â§©ÁöÑÊìç‰ΩúÂ†±Âëä"""
    if not daily_summary:
        return
    
    print("\n" + "=" * 95)
    print("üìÖ ÊØèÊó•Êìç‰ΩúÂ†±Âëä (Strategy 2 - Shared Pool) - ÊúÄËøë 30 Â§©")
    print("=" * 95)
    print(f"{'Êó•Êúü':<12} {'AIÊìç‰Ωú':<6} {'ÂÉπÊ†º':>10} {'Ë≤∑ÂÖ•‰ø°ÂøÉ':>10} {'Ë≥£Âá∫‰ø°ÂøÉ':>10} {'ÂÇôË®ª':<30}")
    print("-" * 95)
    
    for row in daily_summary[-last_n_days:]:
        icon = {'BUY': '‚úÖ', 'SELL': 'üî¥', 'HOLD': '‚è∏Ô∏è'}.get(row['ai_action'], '‚ùì')
        date_str = row['date'].strftime('%Y-%m-%d')
        price_str = f"{row['price']:,.0f}"
        
        buy_conf_str = f"{row['ai_buy_conf']*100:.1f}%" if row['ai_buy_conf'] is not None else "-"
        sell_conf_str = f"{row['ai_sell_conf']*100:.1f}%" if row['ai_sell_conf'] is not None else "-"
        
        print(f"{date_str:<12} {icon} {row['ai_action']:<4} {price_str:>10} {buy_conf_str:>10} {sell_conf_str:>10}  {row['note']:<30}")
    
    print("=" * 95)
    
    # Áµ±Ë®à
    recent = daily_summary[-last_n_days:]
    total_days = len(recent)
    buy_count = sum(1 for r in recent if r['ai_action'] == 'BUY')
    sell_count = sum(1 for r in recent if r['ai_action'] == 'SELL')
    hold_count = total_days - buy_count - sell_count
    
    # ÊúÄÂæå‰∏ÄÂ§©ÁöÑÁ∏ΩÂÄâÊï∏
    final_total = recent[-1]['total_position_count'] if recent else 0
    final_dca = recent[-1]['dca_position_count'] if recent else 0
    final_ai = recent[-1]['ai_position_count'] if recent else 0
    
    print(f"Áµ±Ë®à: Á∏ΩÂ§©Êï∏ {total_days} | AIË≤∑ÂÖ• {buy_count} ÂÄâ | AIË≥£Âá∫ {sell_count} ÂÄâ | HOLD {hold_count} Â§©")
    print(f"ÊúÄÁµÇÊåÅÂÄâ: Á∏Ω {final_total} ÂÄâ (DCA {final_dca} + AI {final_ai})")
    print("=" * 95)


def create_daily_timeline_chart(daily_summary: list, price_df: pd.DataFrame, save_path: str):
    """Áî¢ÁîüÊØèÊó•Êìç‰ΩúÊôÇÈñìÁ∑öÂúñË°®ÔºöÂÉπÊ†ºËµ∞Âã¢+Ë≤∑Ë≥£Èªû„ÄÅÁ∏ΩÂÄâÊï∏ÊôÇÂ∫è"""
    if not daily_summary:
        return
    
    summary_df = pd.DataFrame(daily_summary)
    summary_df.set_index('date', inplace=True)
    
    fig, axes = plt.subplots(2, 1, figsize=(16, 10), gridspec_kw={'height_ratios': [3, 1]})
    
    # 1. ÂÉπÊ†ºËµ∞Âã¢ + AI/DCA Ë≤∑Ë≥£ÈªûÊ®ôË®ò (‰∏çÈ°ØÁ§∫‰ø°ÂøÉÂ∫¶)
    ax1 = axes[0]
    ax1.plot(price_df.index, price_df['Close'], color='black', linewidth=1, label='^TWII')
    
    # AI BUY
    buy_mask = summary_df['ai_action'] == 'BUY'
    if buy_mask.any():
        buy_dates = summary_df[buy_mask].index
        buy_prices = summary_df[buy_mask]['price']
        ax1.scatter(buy_dates, buy_prices, marker='^', color='green', s=80, label='AI BUY', zorder=5)
    
    # AI SELL
    sell_mask = summary_df['ai_action'] == 'SELL'
    if sell_mask.any():
        sell_dates = summary_df[sell_mask].index
        sell_prices = summary_df[sell_mask]['price']
        ax1.scatter(sell_dates, sell_prices, marker='v', color='red', s=80, label='AI SELL', zorder=5)
    
    # DCA BUY (dca_position_count Â¢ûÂä†ÊôÇ)
    dca_positions = summary_df['dca_position_count'].values
    dca_increase = [False] + [dca_positions[i] > dca_positions[i-1] for i in range(1, len(dca_positions))]
    dca_buy_dates = summary_df.index[dca_increase]
    dca_buy_prices = summary_df.loc[dca_buy_dates, 'price']
    if len(dca_buy_dates) > 0:
        ax1.scatter(dca_buy_dates, dca_buy_prices, marker='o', color='blue', s=60, label='DCA BUY', zorder=4, alpha=0.7)
    
    ax1.set_title('Strategy 2 - AI & DCA Trading Signals', fontsize=14)
    ax1.set_ylabel('Price')
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)
    
    # 2. ÂÄâÊï∏ÊôÇÂ∫èÂúñ (Â†ÜÁñäÂçÄÂüüÂúñ: DCA + AI)
    ax2 = axes[1]
    dates = summary_df.index
    dca_pos = summary_df['dca_position_count'].values
    ai_pos = summary_df['ai_position_count'].values
    total_pos = summary_df['total_position_count'].values
    
    # Â†ÜÁñäÂçÄÂüüÂúñ
    ax2.fill_between(dates, 0, dca_pos, alpha=0.6, color='blue', label='DCA ÂÄâ')
    ax2.fill_between(dates, dca_pos, total_pos, alpha=0.6, color='green', label='AI ÂÄâ')
    ax2.plot(dates, total_pos, color='black', linewidth=1.5, label='Á∏ΩÂÄâÊï∏')
    
    # Ê®ôÁ§∫ÊúÄÁµÇÂÄâÊï∏
    final_total = total_pos[-1]
    final_dca = dca_pos[-1]
    final_ai = ai_pos[-1]
    ax2.annotate(f'Á∏Ω{final_total}ÂÄâ\n(DCA{final_dca}+AI{final_ai})', 
                (dates[-1], final_total), 
                textcoords="offset points", xytext=(10, 0), 
                ha='left', fontsize=10, fontweight='bold',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    ax2.set_ylabel('Position Count (ÂÄâÊï∏)')
    ax2.set_xlabel('Date')
    ax2.legend(loc='upper left')
    ax2.grid(True, alpha=0.3)
    ax2.set_ylim(0, max(total_pos) * 1.1)
    
    plt.tight_layout()
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    print(f"[Output] Daily Timeline Chart: {save_path}")
    plt.close()


if __name__ == "__main__":
    main()
